// SPDX-License-Identifier: Apache-2.0
package org.hiero.consensus.otter.docker.app;

import com.google.protobuf.Empty;
import com.hedera.hapi.platform.state.PlatformState;
import edu.umd.cs.findbugs.annotations.NonNull;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hiero.consensus.otter.docker.app.platform.ConsensusNodeManager;
import org.hiero.otter.fixtures.KeysAndCertsConverter;
import org.hiero.otter.fixtures.ProtobufConverter;
import org.hiero.otter.fixtures.container.proto.EventMessage;
import org.hiero.otter.fixtures.container.proto.KillImmediatelyRequest;
import org.hiero.otter.fixtures.container.proto.LogEntry;
import org.hiero.otter.fixtures.container.proto.StartRequest;
import org.hiero.otter.fixtures.container.proto.TestControlGrpc;
import org.hiero.otter.fixtures.container.proto.TransactionRequest;
import org.hiero.otter.fixtures.container.proto.TransactionRequestAnswer;
import org.hiero.otter.fixtures.logging.internal.InMemoryAppender;
import org.hiero.otter.fixtures.result.SubscriberAction;

/**
 * gRPC service implementation for managing communication between the test framework and the platform.
 * <p>
 * This service handles incoming messages to create and start the {@link ConsensusNodeManager} or submit transactions
 * to the platform. It also dispatches outgoing messages such as {@link PlatformState} changes or {@link LogEntry}s
 * generated by the platform via {@link OutboundDispatcher}.
 */
public final class DockerManager extends TestControlGrpc.TestControlImplBase {

    /** Logger */
    private static final Logger LOGGER = LogManager.getLogger(DockerManager.class);

    /** Executor service for handling the dispatched messages */
    private final ExecutorService executor;

    /** Manages the consensus nodes and platform lifecycle */
    private ConsensusNodeManager nodeManager;

    /** Handles outgoing messages, may get called from different threads/callbacks */
    private volatile OutboundDispatcher dispatcher;

    /**
     * Constructs a DockerManager instance with the specified executor service.
     *
     * @param executor The executor service used for asynchronous operations.
     * @throws NullPointerException if the executor is null.
     */
    public DockerManager(@NonNull final ExecutorService executor) {
        this.executor = Objects.requireNonNull(executor, "executor cannot be null");
    }

    /**
     * Starts the communication channel with the platform using the provided {@link StartRequest}.
     *
     * This method initializes the {@link ConsensusNodeManager} and sets up listeners for platform events.
     * Results are sent back to the test framework via the {@link StreamObserver}.
     *
     * @param request The request containing details required to construct the platform.
     * @param responseObserver The observer used to send messages back to the test framework.
     * @throws StatusRuntimeException if the platform is already started, or if the request contains invalid arguments.
     */
    @Override
    public synchronized void start(
            @NonNull final StartRequest request, @NonNull final StreamObserver<EventMessage> responseObserver) {
        if (nodeManager != null) {
            responseObserver.onError(Status.ALREADY_EXISTS.asRuntimeException());
            return;
        }

        if (isInvalidRequest(request, responseObserver)) {
            return;
        }

        try {
            nodeManager = new ConsensusNodeManager(
                    ProtobufConverter.toPbj(request.getSelfId()),
                    ProtobufConverter.toPbj(request.getVersion()),
                    ProtobufConverter.toPbj(request.getRoster()),
                    KeysAndCertsConverter.fromProto(request.getKeysAndCerts()),
                    request.getOverriddenPropertiesMap());

            dispatcher = new OutboundDispatcher(executor, responseObserver);

            // Capture the dispatcher in a final variable so the lambda remains valid
            final OutboundDispatcher currentDispatcher = dispatcher;

            nodeManager.registerPlatformStatusChangeListener(
                    notification -> dispatcher.enqueue(EventMessageFactory.fromPlatformStatusChange(notification)));

            nodeManager.registerConsensusRoundListener(
                    rounds -> dispatcher.enqueue(EventMessageFactory.fromConsensusRounds(rounds)));

            InMemoryAppender.subscribe(log -> {
                dispatcher.enqueue(EventMessageFactory.fromStructuredLog(log));
                return currentDispatcher.isCancelled() ? SubscriberAction.UNSUBSCRIBE : SubscriberAction.CONTINUE;
            });

            nodeManager.start();
        } catch (final Exception e) {
            LOGGER.error("Unexpected error while starting grpc server", e);
            if (dispatcher != null) {
                dispatcher.shutdown();
            }
            responseObserver.onError(Status.INTERNAL.withCause(e).asRuntimeException());
        }
    }

    /**
     * Checks if the provided {@link StartRequest} is invalid and sends an error response if necessary.
     *
     * This method validates the fields of the {@link StartRequest}.
     * If any of the conditions are not met, an appropriate error is sent to the {@link StreamObserver}.
     *
     * @param request The {@link StartRequest} containing the details for starting the platform.
     * @param responseObserver The observer used to send error messages back to the test framework.
     * @return {@code true} if the request is invalid; {@code false} otherwise.
     */
    private static boolean isInvalidRequest(
            final StartRequest request, final StreamObserver<EventMessage> responseObserver) {
        if (request.getSelfId().getId() < 0) {
            responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("selfId must be positive")
                    .asRuntimeException());
            return true;
        }
        if (!request.hasVersion()) {
            responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("version has to be specified")
                    .asRuntimeException());
            return true;
        }
        if (!request.hasRoster()) {
            responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("roster has to be specified")
                    .asRuntimeException());
            return true;
        }
        return false;
    }

    /**
     * Submits a transaction to the platform.
     *
     * This method sends the transaction payload to the platform for processing.
     *
     * @param request The transaction request containing the payload.
     * @param responseObserver The observer used to confirm transaction submission.
     * @throws StatusRuntimeException if the platform is not started or if an internal error occurs.
     */
    @Override
    public synchronized void submitTransaction(
            @NonNull final TransactionRequest request,
            @NonNull final StreamObserver<TransactionRequestAnswer> responseObserver) {
        if (nodeManager == null) {
            responseObserver.onError(Status.FAILED_PRECONDITION
                    .withDescription("Application not started yet")
                    .asRuntimeException());
            return;
        }

        try {
            final boolean result =
                    nodeManager.submitTransaction(request.getPayload().toByteArray());
            responseObserver.onNext(
                    TransactionRequestAnswer.newBuilder().setResult(result).build());
            responseObserver.onCompleted();
        } catch (final Exception e) {
            responseObserver.onError(Status.INTERNAL.withCause(e).asRuntimeException());
        }
    }

    /**
     * Immediately terminates the platform and cleans up resources.
     *
     * This method stops the {@link ConsensusNodeManager} and shuts down the dispatcher.
     *
     * @param request The request to terminate the platform.
     * @param responseObserver The observer used to confirm termination.
     * @throws RuntimeException if the termination process is interrupted.
     */
    @Override
    public synchronized void killImmediately(
            final KillImmediatelyRequest request, final StreamObserver<Empty> responseObserver) {
        try {
            if (nodeManager != null) {
                nodeManager.destroy();
                nodeManager = null;
            }

            if (dispatcher != null) {
                dispatcher.shutdown();
            }

            responseObserver.onNext(Empty.getDefaultInstance());
            responseObserver.onCompleted();
        } catch (final InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }
}
